( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Copyright [c] 2009, Charles Childers                        )
( License: ISC                                                )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )

( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( This is a block editor that I've been using for many years. )
( It's simple, and doesn't have a lot of features, but it is  )
( more than enough for most of my prototyping work.           )
(                                                             )
( Actually, it's proven more popular than I ever expected. It )
( has been used by many of Retro's users, and implementations )
( now exist for several other Forth systems.                  )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Line and column numbers start at 0.                         )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Quick Reference:                                            )
(      # s        Select a new block                          )
(        p        Previous block                              )
(        n        Next block                                  )
(      # i ..     Insert .. into line                         )
(   # #2 ia ..    Insert .. into line [#2] starting at        )
(                 column [#]                                  )
(        x        Erase the current block                     )
(      # d        Erase the specified line                    )
(        v        Display the current block                   )
(        e        Evaluate Block                              )
(        ea       Evaluate All Blocks                         )
(        new      Erase all blocks                            )
( # set-blocks    Set the # of blocks. Calls 'new'            )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( The memory layout and basic configuration.                  )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
variable #-blocks
variable offset

10 variable: line-ending

variable blk
: block     512 * offset @ + ;
: (block)   blk @ block ;
: (line)    64 * (block) + ;

stub (v)
stub (ia)
: v   ( -  ) (v) ;
: s   ( n- ) blk ! v ;
: d   ( n- ) (line) 32 64 fill v ;
: x   ( -  ) (block) 32 512 fill v ;
: p   ( -  ) blk -- v ;
: n   ( -  ) blk ++ v ;
: ia  ( nn"- ) (ia) ;
: i   ( n"- ) 0 swap ia v ;
: new ( -  ) offset @ 32 512 #-blocks @ * fill ;
: e   ( -  ) (block) 512 eval ;
: ea  ( -  ) offset @ #mem @ over - eval ;

( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Default Block Viewer                                        )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
{
  : type    for @+ emit next drop ;
  : space   32 emit ;
  : row     . dup 64 type 64 + cr ;
  : .rows   0 row 1 row 2 row 3 row
            4 row 5 row 6 row 7 row ;
  : .block  ." Block: " blk @ . ." of " #-blocks @ 1- . ;
  : x       ." +---:---+---:---" ;
  : bar     space space x x x x cr ;
  : vb      bar blk @ block .rows drop bar ;
  here is (v) ] clear vb .block ;
}


( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Default "Insert At"                                         )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
{
  variable ws
  : nofilter ( - ) whitespace dup @ ws ! off later ws @ whitespace ! ;
  : getline  ( - ) line-ending @ accept ;
  : setup    ( nn-aan ) tib swap tib getLength ;
  here is (ia) ] nofilter (line) + getline setup copy v ;
}

: set-blocks
  #-blocks ! #mem @ 512 #-blocks @ * - offset ! new ;


( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( All done! Fill the blocks with spaces, and we're good to go )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
64 set-blocks


( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( "see" - a simple decompiler                                 )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
{{
  variable addr

  : pad       ( -    ) addr @ @ 6 for dup base @ r pow <if 32 emit then next ;

  : .wrap     ( -   ) ." ( " later ."  )" ;
  : .name     ( a-  ) .wrap d->name type ;
  : resolve   ( -   ) last @ repeat dup d->xt @ addr @ @ =if .name ;then 0; @ again ;

  : token     ( "-  ) 32 accept tib keepString literal, ;
  : .op       ( a-  ) dup getLength swap type 6 swap - 0; for 32 emit next ;
  : .symbol   ( "-  ) token ` .op ` drop ; immediate
  : .value    (  -  ) addr ++ addr @ @ . pad resolve ;
  : sym:      ( "-  ) ` over ` =if ` .symbol ` ;then ; immediate
  : sym+:     ( "-  ) ` over ` =if ` .symbol ` .value ` ;then ; immediate

  : .ascii    ( c-  ) dup 32 128 within if 39 emit emit 39 emit then ;

  : decompile ( -   )
    addr @ @
     0 sym: nop      1 sym+: lit      2 sym: dup       3 sym: drop
     4 sym: swap     5 sym: push      6 sym: pop       7 sym+: call
     8 sym+: jump    9 sym: ;        10 sym+: >jump   11 sym+: <jump
    12 sym+: !jump  13 sym+: =jump   14 sym: @        15 sym: !
    16 sym: +       17 sym: -        18 sym: *        19 sym: /mod
    20 sym: and     21 sym: or       22 sym: xor      23 sym: <<
    24 sym: >>      25 sym: 0;       26 sym: 1+       27 sym: 1-
    28 sym: in      29 sym: out      30 sym: wait
    ." Unknown: " dup . .ascii
  ;

  : header? addr @ @ 9 =if addr @ 1+ @ 30 >if addr @ . decompile pop pop 2drop then then ;
  : vector? addr @ @ 0 =if addr @ 1+ @ 0 =if pop pop 2drop then then ;
  : more? header? vector? ;
---reveal---
  : see  ( "-  ) ' addr ! cr repeat addr @ . decompile cr addr ++ more? again ;
}}

save
bye
